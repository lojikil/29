#@(#) a miniature compiler for carML, written in carML
#@(#) meant to get us over the hump and actually be able
#@(#) to do simple things like check if a function was
#@(#) defined when producing code, and a nicer REPL
#@(#) this also should allow us to do other nicer
#@(#) things in the compiler, like dump bindings for
#@(#) all defined functions; note, this is called
#@(#) a mini-compiler to differentiate it from the
#@(#) full compiler. The delineation there is that
#@(#) this one still relies on what I originally wrote
#@(#) in C itself, whereas the full compiler will not
#@(#) be reliant upon that. As well, the fully compiler
#@(#) will have a properly typed AST, rather than the
#@(#) current array[ref[AST]]-typed one

# build a spaghetti stack of environment frames
# this would be nicer if we had two things:
#
# . vecdeques
# . tries
#
# if we had the first, we wouldn't need to track
# anything more about the object other than the
# vector, and if we had the second we could do
# faster lookups; currently we will have to iterate
# over the entire memberlist to find a match

record EnvFrame {
    curfunc : int
    lenfuncs : int
    funcs : array[ref[AST]]
    curval : int
    lenvals : int
    vals : array[ref[AST]]
    curvar : int
    lenvars : int
    vars : array[ref[AST]]
    currec : int
    lenrecs : int
    recs : array[ref[AST]]
    curtype : int
    lentypes: int
    types: array[ref[AST]]
    curpoly :int
    lenpolys:int
    polys: array[ref[AST]]
    curdec : int
    lendecs: int
    decs: array[ref[AST]]
    curmod : int
    lenmods: int
    mods: array[ref[AST]]
    parent: ref[EnvFrame]
}

# add an environment frame to the spaghetti stack
def new-env-frame src:ref[EnvFrame] => ref[EnvFrame] = {

}

# add an AST to the correct place
def add-member! src:ref[AST] dst:ref[EnvFrame] => bool = {
    # I *reallllllllly* want accessors...
    val tag : int = (-> src tag)
    # also, I reaaaaaaally need to fix that `match` function
    # call bug
    # additionally, it will be really nice to get rid of some
    # of this imperative code here... a nice monadic interface
    # for these would work too...
    # lastly, a nice vector dequeue implementation would elide
    # a lot of the detail that I'm manually doing in here...
    match tag with
        TMODULE => {
            # we also need to handle the case when the length is
            # at capacity, and need to update that...
            when (eq? (-> dst curmod) (-> dst lenmods)) do {
                return false
            }
            set! (get (-> dst mods) (-> dst curmod)) src
            set! (-> dst curmod) $ + 1 $ -> dst curmod
        }
        TDEF => {
            set! (get (-> dst funcs) (-> dst curfunc)) src
            set! (-> dst curfunc) $ + 1 $ -> dst curfunc
        }
        TVAL => {
            set! (get (-> dst vals) (-> dst curval)) src
            set! (-> dst curval) $ + 1 $ -> dst curval
        }
        TVAR => {
            set! (get (-> dst vars) (-> dst curvar)) src
            set! (-> dst curvar) $ + 1 $ -> dst curvar
        }
        TTYPE => {
            set! (get (-> dst types) (-> dst curtype)) src
            set! (-> dst curtype) $ + 1 $ -> dst curtype
        }
        TPOLY => {
            set! (get (-> dst polys) (-> dst curpoly)) src
            set! (-> dst curpoly) $ + 1 $ -> dst curpoly
        }
        TDECLARE => {
            set! (get (-> dst decs) (-> dst curdec)) src
            set! (-> dst curdec) $ + 1 $ -> dst curdec
        }
        else => (return false)
    end
    true
}

def has-member? member:ref[AST] src:array[ref[AST]] idx:int => bool = {
    when (>= idx (len src)) do {
        return false
    }

    if (eq? (-> member value) (-> (get src idx) value)) then
        true
    else
        (has-member? member src (+ idx 1))
}

# check if a function is defined either as our curent functions
# or as our current declarations
def function-defined? src:ref[AST] env:ref[EnvFrame] => bool = {

}

# do we have a val/var/declaration for this?
def ident-defined? src:ref[AST] env:ref[EnvFrame] => bool = {

}

# should start with a simple type checker, to make sure we're
# roughly not violating type guarantees
def type-check src:ref[AST] env:ref[EnvFrame] => bool = {

}

# make sure that a set (`set!` or `:=`) isn't breaking const guarantees
def const-check src:ref[AST] env:ref[EnvFrame] => bool = {

}

# a miniature compiler; basically just collects things together
# and stores them, but makes sure we have resolved all references
#
# for example, if we reference a variable `bar` in function `foo`,
# minicompile will warn if `bar` hasn't been defined in the environment
def minicompile src:ref[AST] env:ref[EnvFrame] => int = {

}

# given an environment, dump the entirety of our output
# to stdout, in whatever destination language we request
def minicompileworld env:ref[EnvFrame] => int = {

}
