#@(#) a miniature compiler for carML, written in carML
#@(#) meant to get us over the hump and actually be able
#@(#) to do simple things like check if a function was
#@(#) defined when producing code, and a nicer REPL
#@(#) this also should allow us to do other nicer
#@(#) things in the compiler, like dump bindings for
#@(#) all defined functions; note, this is called
#@(#) a mini-compiler to differentiate it from the
#@(#) full compiler. The delineation there is that
#@(#) this one still relies on what I originally wrote
#@(#) in C itself, whereas the full compiler will not
#@(#) be reliant upon that. As well, the fully compiler
#@(#) will have a properly typed AST, rather than the
#@(#) current array[ref[AST]]-typed one

# build a spaghetti stack of environment frames
# this would be nicer if we had two things:
#
# . vecdeques
# . tries
#
# if we had the first, we wouldn't need to track
# anything more about the object other than the
# vector, and if we had the second we could do
# faster lookups; currently we will have to iterate
# over the entire memberlist to find a match

record EnvFrame {
    curobj:int
    curmod:int
    lenobjs:int
    lenmods:int
    object_names:array[string]
    object_vals:array[ref[AST]]
    module_names:array[string]
    module_vals:array[ref[AST]]
}

# add an environment frame to the spaghetti stack
def new-env-frame src:ref[EnvFrame] => ref[EnvFrame] = {
    var ret:ref[EnvFrame] = (hmalloc $ sizeof EnvFrame)
    set! (-> ret parent) src
    ret
}

# add an AST to the correct place
def add-member! src:ref[AST] dst:ref[EnvFrame] => bool = {
    # I *reallllllllly* want accessors...
    val tag : int = (-> src tag)
    # also, I reaaaaaaally need to fix that `match` function
    # call bug
    # additionally, it will be really nice to get rid of some
    # of this imperative code here... a nice monadic interface
    # for these would work too...
    # lastly, a nice vector dequeue implementation would elide
    # a lot of the detail that I'm manually doing in here...
    match tag with
        TMODULE => {
            # we also need to handle the case when the length is
            # at capacity, and need to update that...
            when (eq? (-> dst curmod) (-> dst lenmods)) do {
                return false
            }
            set! (get (-> dst module_vals) (-> dst curmod)) src
            set! (get (-> dst module_names) (-> dst curmod)) (-> src value)
            set! (-> dst curmod) $ + 1 $ -> dst curmod
        }
        else => {
            # we also need to handle the case when the length is
            # at capacity, and need to update that...
            when (eq? (-> dst curobj) (-> dst lenmods)) do {
                return false
            }
            set! (get (-> dst object_vals) (-> dst curobj)) src
            set! (get (-> dst object_names) (-> dst curobj)) (-> src value)
            set! (-> dst curobj) $ + 1 $ -> dst curobj
        }
    end
    true
}

def has-member? member:ref[AST] src:array[ref[AST]] idx:int => bool = {
    when (>= idx (len src)) do {
        return false
    }

    if (eq? (-> member value) (-> (get src idx) value)) then
        true
    else
        (has-member? member src (+ idx 1))
}

# check if a function is defined either as our curent functions
# or as our current declarations
def function-defined? src:ref[AST] env:ref[EnvFrame] => bool = {
    match env with
        NULL => false
        else =>
                (one-of
                    (has-member? src (-> env funcs))
                    (has-member? src (-> env decs))
                    (function-defined src (-> env parent)))
    end
}

# do we have a val/var/declaration for this?
def ident-defined? src:ref[AST] env:ref[EnvFrame] => bool = {
    match env with
        NULL => false
        else =>
                (one-of
                    (has-member? src (-> env vals))
                    (has-member? src (-> env vars))
                    (has-member? src (-> env decs))
                    (ident-defined? src (-> env parent)))
    end
}

# should start with a simple type checker, to make sure we're
# roughly not violating type guarantees
def type-check src:ref[AST] env:ref[EnvFrame] => bool = {
    false
}

# make sure that a set (`set!` or `:=`) isn't breaking const guarantees
def const-check src:ref[AST] env:ref[EnvFrame] => bool = {
    match env with
        NULL => false
        else =>
                (one-of
                    (has-member? src (-> env vals))
                    (const-check src (-> env parent)))
    end
}

def is-defined? src:ref[AST] env:ref[EnvFrame] => bool = {
    # this would be so much nicer as a ADT/Discriminated Union
    when (eq? src NULL) do {
        return true
    }
    # this is such a hack...
    match src->tag with
        # do we actually need to break each of these out?
        # the only things we need to *really* check are:
        #
        # . are all members defined?
        #
        # any other property should be checked by better
        # suited functions...
        TCALL => {

        }
        TMATCH => {

        }
        TBEGIN => {

        }
        TWHILE => {

        }
        TIF => {
        }
        TWHEN => {
        }
    end
}

# a miniature compiler; basically just collects things together
# and stores them, but makes sure we have resolved all references
#
# for example, if we reference a variable `bar` in function `foo`,
# minicompile will warn if `bar` hasn't been defined in the environment
def minicompile src:ref[AST] env:ref[EnvFrame] => int = {

}

# given an environment, dump the entirety of our output
# to stdout, in whatever destination language we request
def minicompileworld env:ref[EnvFrame] => int = {

}
