# @(#) an attempt at writing a self-tail call detection
# @(#) and optimization system for carML/C in carML
# @(#) itself. This provides two functions:
# @(#)
# @(#) 1. `self-tco?`, which determines if the function is a tail call
# @(#) 1. `rewrite-tco`, which returns a `while` and shadowed variant
# @(#)
# @(#) this is meant to only interact with the carML/C compiler

def self-tco? name:string src:ref[AST] => bool = {
    var res:bool = false
    var idx:int = 0
    val tag:int = (-> src tag)

    # just working around a bug in the C output that
    # results from the fact that we're not yet actually
    # tracking types in a useful way...
    match tag with 
        TDEF => (self-tco? name (-> src $ get children 1))
        TFN => (self-tco? name (-> src $ get children 1))
        TCALL => (not (strncmp name (-> src $ -> (get children 0) value)))
        TBEGIN => {
            # actually, thinking about it...
            # we don't really need to loop over all forms, just
            # jump straight to the last form and check if it
            # is a TCO-able form
            set! idx $ - (-> src lenchildren) 1
            self-tco? name (-> src $ get children idx)
        }
        TWHEN => (self-tco? name (-> src $ get children 1))
        TIF => (one-of 
                (self-tco? name (-> src $ get children 1))
                (self-tco? name (-> src $ get children 2)))
        TMATCH => {
            # now HERE we must check each form to see if
            # it is TCO-able. the way that we store TMATCH
            # then-forms is along the spine, so that each
            # form is basically:
            # `(match CONDITION (array (array CASE THEN)))`
            # this allows us to easily store the system, but
            # obviously it also means that we must linearlly
            # traverse the spine... but only need to check
            # the odd indicies of the spine
            set! idx 1

            # as an aside...
            # I often use `{}` pairs in forms just to visually
            # demarcate what I'm doing, not for any other reason

            while (< idx $ -> src lenchildren) do {
                if (self-tco? name $ -> src $ get children idx) then
                    true
                else
                    (set! idx $ + idx 2)
            }

            false
        }
        else => false
    end
}

def shadow-params src:ref[AST] impl:ref[AST] => ref[AST] = {
    var ret : ref[AST] = (hmalloc $ sizeof ref[AST])
    val clen: int = (* (-> src lenchildren) 2)
    var idx : int = 0
    var sidx : int = 0
    set! (-> ret tag) TBEGIN
    set! (-> ret lenchildren) clen
    set! (-> ret children) $ hmalloc $ * clen $ sizeof ref[AST]
    # NOTE again! this would be a great place for a nice map/foreach/whatever
    # fusion system. What we need to do is basically:
    # `zip src $ map (compose shadow-name get-param-name) impl`
    # so that we end up with an array of tuples for `(shadowed-name value)`
    # and then do the same for shadow-names and param-names. a nice foreach
    # would be useful to iterate over both...
    #
    # also, it would be interesting to have a compose function that did nothing
    # but compose things in a useful way, like `.$.` or the like...
    #
    # the more I think about `.$.` syntax or the like the more I like it...
    # think about it...
    #
    # Inline: `(List.Map foo .$. bar arr)` => `(List.Map (fn (x) (foo (bar x))) arr)`
    # Explicit: `(List.Map (.$. foo bar baz bla) arr)` =>
    # `(List.Map (fn (x) (foo $ bar $ baz $ bla x)) arr)`
    #
    # the `.$.` doesn't have to create an implicit closure, but for purposes it treats
    # the two functions as methods that need to be composed...
    # $> maybe?
    while (< idx clen) do {
        # woof, really need to decompose this. Let's break it down:
        # 1. create the shadowed ident
        # 1. grab the parameter's value
        # 1. create the shadow set `(set! shadowed-name parameter value)`
        # 1. create the join set `(set! original-name shadowed-name)`
        set! (get (-> ret children) idx) $ make-set-bang (shadow-name $ get-param-name impl sidx) (get (-> src children) sidx)
        set! (get (-> ret children) $ + idx 1) $ make-set-bang (get-param-name impl sidx)
    }
}


# NOTE: the below three functions are just utilities to make writing
# things slightly more nice, but it really feels like they could
# easily be inlined a bunch opportunistically... I need to read more
# about what OCaml is doing in flambda for their heuristics. There's
# some literal number (like 30) where if the function has less than
# this numer of operations, it is just inlined.
#
# - https://caml.inria.fr/pub/docs/manual-ocaml/flambda.html
# - https://github.com/OCamlPro/flambda-task-force/issues/103
# - https://ocaml.janestreet.com/ocaml-core/flambda_manual/
#
def shadow-name name:string => string = {
    var ret : array[char] = (hmalloc $ + 3 $ * (sizeof char) (strlen name))
    stpcpy ret name
    strcat ret "_sh"
    ret
}

def get-parameter-name src:ref[AST] idx:int => string = {
    val ret:ref[AST] = nil
    when (< idx $ -> src lenchildren) do {
        # XXX *wow* talk about something that would be
        # much nicer with lenses... or really a monadic
        # interface with not-null and some other stuff...
        # part of the other problem here is that we don't
        # have a nicely defined AST interface, I went with
        # a fairly generic interface (so as to only have
        # one structure definition...) that means we do
        # a lot of children indexing...
        set! ret $ -> src $ get children idx
        set! ret $ -> ret $ get children 0
        return $ -> ret value
    }
    ""
}

def get-parameter-ident src:ref[AST] idx:int => ref[AST] = {
    val ret:ref[AST] = nil
    when (< idx $ -> src lenchildren) do {
        set! ret $ -> src $ get children idx
        return $ -> ret $ get children 0
    }
    nil
}

def get-parameter-type src:ref[AST] idx:int => ref[AST] = {
    val ret:ref[AST] = nil
    when (< idx $ -> src lenchildren) do {
        set! ret $ -> src $ get children idx
        return $ -> ret $ get children 1
    }
    nil
}

def define-shadow-params src:ref[AST] => ref[AST] = {
    # the more I code these, the more I really want to
    # make the simple compiler...
    # esp to track accessors.
    # oh... wait that's a good idea. I can write a simple
    # compiler in carML right now, much like these...
    var ret : ref[AST] = (hmalloc $ sizeof ref[AST])
    var tmp : ref[AST] = nil
    var idx : int = 0
    set! (-> ret tag) TBEGIN
    set! (-> ret lenchildren) (-> src lenchildren)
    set! (-> ret children) (hmalloc $ * (-> src lenchildren) (sizeof ref[ref[AST]]))
    # this would be an ideal location for `Array.map`: we need to
    # iterate over each member of the `src` member, and transform
    # it from a `parameter-definition` into a `var` and tweak the
    # name a little...
    while (< idx $ -> src lenchildren) do {
        set! tmp $ hmalloc $ sizeof ref[AST]
        set! (-> tmp tag) TVAR
        # so a TVAR is:
        # _value : string = name
        # _2: ref[AST] = value
        # _3: ref[AST] = type
        #
        # would also be a great place for `String.Join`
        set! (-> tmp lenchildren) 2
        set! (-> tmp value) $ shadow-name $ get-parameter-name src idx
        set! (-> tmp children) $ hmalloc $ * 2 $ sizeof ref[AST]
        set! (-> tmp $ get children 0) $ get-parameter-ident src idx
        set! (-> tmp $ get children 1) $ get-parameter-type src idx
        set! (-> ret $ get children idx) tmp
        set! idx $ + idx 1
    }
    ret 
}

def rewrite-tco src:ref[AST] => ref[AST] = {
    val params : ref[AST] = (define-shadow-params $ -> src $ get children 0)
    var ret : ref[AST] = (hmalloc $ sizeof ref[AST])
    # what we need to do is effectively copy the spine of the original AST
    # form, and replace certain portions with some shadowing components
    # thrown into the spine. so for example:
    #
    # ```
    # def foo x:int y:int => int = if (> x 10) then y else (foo (+ x 1) (+ x y))
    # # this should become...
    # def foo x:int y:int => int = {
    #     var x_shadow:int = x
    #     var y_shadow:int = y
    #     while true do {
    #         if (> x 10) then
    #           (return y)
    #         else {
    #           set! x_shadow (+ x 1)
    #           set! y_shadow (+ x y)
    #           set! x x_shadow
    #           set! y y_shadow
    #         }
    #   }
    #```
    #
    # this way we can make the tail call into the semantically similar loop
    # and not have to rely on the C/Golang compiler doing it for us...
    #
    # additionally, we need a mechanism by which we know we're rewriting a
    # tail call, rather than just rewriting all calls. So basically we need
    # to follow the following general idea:
    #
    # 1. shadow parameters in definitions
    # 1. walk the spine
    #     1. if not tail, copy the form
    #     1. if tail, rewrite as needed
    #
    # rewriting should do the following:
    #
    # 1. not hop into `while` and `for` bodies
    # 1. rewrite either-side of an `if`, one side of a `when`, &c
    # 1. this rewrite should be: if it is not a tail-call, prefix it with `return`
    # 1. if it *is* a tail call, shadow call
    set! (-> ret tag) TDEF
    set! (-> ret lenchildren) 3 # parameter list, return type, body
    set! (-> ret children) $ hmalloc $ * 3 $ sizeof ref[ref[AST]]

    # XXX should we mung the name here to indicate it has been
    # rewritten? probably not for production/release builds, but
    # maybe for debug?
    set! (-> ret value) (-> src value)

    set! (-> ret $ get children 0) (-> src $ get children 0)
    # I know why I did that; I originally was going to make
    # return types completely optional (for inference)
    set! (-> ret $ get children 2) (-> src $ get children 2)
    set! (-> ret $ get children 1) params
    ret
}
