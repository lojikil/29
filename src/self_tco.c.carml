# @(#) an attempt at writing a self-tail call detection
# @(#) and optimization system for carML/C in carML
# @(#) itself. This provides two functions:
# @(#)
# @(#) 1. `self-tco?`, which determines if the function is a tail call
# @(#) 1. `rewrite-tco`, which returns a `while` and shadowed variant
# @(#)
# @(#) this is meant to only interact with the carML/C compiler

def self-tco? name:string src:ref[AST] => bool = {
    var res:bool = false
    var idx:int = 0
    val tag:int = (-> src tag)

    # just working around a bug in the C output that
    # results from the fact that we're not yet actually
    # tracking types in a useful way...
    match tag with 
        TDEF => (self-tco? name (-> src $ get children 1))
        TFN => (self-tco? name (-> src $ get children 1))
        TCALL => (not (strncmp name (-> src $ -> (get children 0) value)))
        TBEGIN => {
            # actually, thinking about it...
            # we don't really need to loop over all forms, just
            # jump straight to the last form and check if it
            # is a TCO-able form
            set! idx $ - (-> src lenchildren) 1
            self-tco? name (-> src $ get children idx)
        }
        TWHEN => (self-tco? name (-> src $ get children 1))
        TIF => (one-of 
                (self-tco? name (-> src $ get children 1))
                (self-tco? name (-> src $ get children 2)))
        TMATCH => {
            # now HERE we must check each form to see if
            # it is TCO-able. the way that we store TMATCH
            # then-forms is along the spine, so that each
            # form is basically:
            # `(match CONDITION (array (array CASE THEN)))`
            # this allows us to easily store the system, but
            # obviously it also means that we must linearlly
            # traverse the spine... but only need to check
            # the odd indicies of the spine
            set! idx 1

            # as an aside...
            # I often use `{}` pairs in forms just to visually
            # demarcate what I'm doing, not for any other reason

            while (< idx $ -> src lenchildren) do {
                if (self-tco? name $ -> src $ get children idx) then
                    true
                else
                    (set! idx $ + idx 2)
            }

            false
        }
        else => false
    end
}

def shadow-params src:ref[AST] impl:ref[AST] => ref[AST] = {
    nil
}


# NOTE: the below three functions are just utilities to make writing
# things slightly more nice, but it really feels like they could
# easily be inlined a bunch opportunistically... I need to read more
# about what OCaml is doing in flambda for their heuristics. There's
# some literal number (like 30) where if the function has less than
# this numer of operations, it is just inlined.
#
# - https://caml.inria.fr/pub/docs/manual-ocaml/flambda.html
# - https://github.com/OCamlPro/flambda-task-force/issues/103
# - https://ocaml.janestreet.com/ocaml-core/flambda_manual/
#
def shadow-name name:string => string = {
    var ret : array[char] = (hmalloc $ + 3 $ * (sizeof char) (strlen name))
    stpcpy ret name
    strcat ret "_sh"
    ret
}

def get-parameter-name src:ref[AST] idx:int => string = {
    ""
}

def get-parameter-ident src:ref[AST] idx:int => ref[AST] = {
    nil
}

def get-parameter-type src:ref[AST] idx:int => ref[AST] = {

}

def define-shadow-params src:ref[AST] => ref[AST] = {
    # the more I code these, the more I really want to
    # make the simple compiler...
    # esp to track accessors.
    # oh... wait that's a good idea. I can write a simple
    # compiler in carML right now, much like these...
    var ret : ref[AST] = (hmalloc $ sizeof ref[AST])
    var tmp : ref[AST] = nil
    var idx : int = 0
    set! (-> ret tag) TBEGIN
    set! (-> ret lenchildren) (-> src lenchildren)
    set! (-> ret children) (hmalloc $ * (-> src lenchildren) (sizeof ref[ref[AST]]))
    # this would be an ideal location for `Array.map`: we need to
    # iterate over each member of the `src` member, and transform
    # it from a `parameter-definition` into a `var` and tweak the
    # name a little...
    while (< idx $ -> src lenchildren) do {
        set! tmp $ hmalloc $ sizeof ref[AST]
        set! (-> tmp tag) TVAR
        # so a TVAR is:
        # _value : string = name
        # _2: ref[AST] = value
        # _3: ref[AST] = type
        #
        # would also be a great place for `String.Join`
        set! (-> tmp lenchildren) 2
        set! (-> tmp value) $ shadow-name $ get-paramter-name src idx
        set! (-> tmp children) $ hmalloc $ * 2 $ sizeof ref[AST]
        set! (-> tmp $ get children 0) $ get-parameter-ident src idx
        set! (-> tmp $ get children 1) $ get-parameter-type src idx
        set! (-> ret $ get children idx) tmp
        set! idx $ + idx 1
    }
    ret 
}

def rewrite-tco src:ref[AST] => ref[AST] = {
    val params : ref[AST] = (define-shadow-params $ -> src $ get children 1)
    var ret : ref[AST] = (hmalloc $ sizeof ref[AST])
    # what we need to do is effectively copy the spine of the original AST
    # form, and replace certain portions with some shadowing components
    # thrown into the spine. so for example:
    #
    # ```
    # def foo x:int y:int => int = if (> x 10) then y else (foo (+ x 1) (+ x y))
    # # this should become...
    # def foo x:int y:int => int = {
    #     var x_shadow:int = x
    #     var y_shadow:int = y
    #     while true do {
    #         if (> x 10) then
    #           (return y)
    #         else {
    #           set! x_shadow (+ x 1)
    #           set! y_shadow (+ x y)
    #           set! x x_shadow
    #           set! y y_shadow
    #         }
    #   }
    #```
    #
    # this way we can make the tail call into the semantically similar loop
    # and not have to rely on the C/Golang compiler doing it for us...
    #
    # additionally, we need a mechanism by which we know we're rewriting a
    # tail call, rather than just rewriting all calls. So basically we need
    # to follow the following general idea:
    #
    # 1. shadow parameters in definitions
    # 1. walk the spine
    #     1. if not tail, copy the form
    #     1. if tail, rewrite as needed
    #
    # rewriting should do the following:
    #
    # 1. not hop into `while` and `for` bodies
    # 1. rewrite either-side of an `if`, one side of a `when`, &c
    # 1. this rewrite should be: if it is not a tail-call, prefix it with `return`
    # 1. if it *is* a tail call, shadow call
}
